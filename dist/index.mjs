var v=Object.defineProperty;var A=(e,t)=>{for(var n in t)v(e,n,{get:t[n],enumerable:!0})};import{Node as D,Project as w}from"ts-morph";import{Node as C}from"ts-morph";function E(e){let t=[];return e.forEachDescendant(n=>{if(C.isVariableDeclaration(n)){let r=n.getName(),o=n.getType().getText();t.push({name:r,type:o})}}),t}function p(e,t){let n=e.getFunction(t)||e.getFirstDescendant(r=>C.isFunctionExpression(r)&&r.getName()===t);if(n)return E(n)}function S(e){if(D.isFunctionDeclaration(e)){let t=e.getName()||"anonymous",n=e.getReturnType().getText(),r=e.getParameters().map(i=>({name:i.getName(),type:i.getType().getText()})),o=e.getJsDocs()[0]?.getDescription();return{name:t,returnType:n,parameters:r,jsDocComment:o,code:e.getText(),variables:p(e.getSourceFile(),t)}}return null}function k(e){let n=new w().createSourceFile("temp.ts",e),r=[],o=[];return n.forEachDescendant(a=>{let i=S(a);i&&(r.push(i),i.returnType&&o.push(i.returnType),i.parameters?.forEach(u=>o.push(u.type)))}),{functionsInfo:r,usedTypes:o}}var l="Promise<";function m(e,t,n=!0,r=1/0){let o=e.filter((a,i)=>i<r);return n?o.reverse().find(a=>a.type===t):o.find(a=>a.type===t)}function x(e,t){let n=new Set(t.map(({name:a})=>a));if(!n.has(e))return e;let r=2,o=`${e}${r}`;for(;n.has(o);)r++,o=`${e}${r}`;return o}function f(e){return e?.startsWith(l)?e.slice(l.length,-1):e??"any"}function P(e){return e.map((t,n)=>({name:t.name.toLowerCase(),type:f(t.returnType),index:n}))}import{factory as s,NodeFlags as B}from"typescript";function V(e,t){return s.createVariableStatement(void 0,s.createVariableDeclarationList([$(e.returnVariable?.name,e.functionInfo,t.variables,e.index)],B.Const))}function h(e,t,n){let r=W(e,t,n),o=j(e,r);return e.returnType?.includes(l)?s.createAwaitExpression(o):o}function W(e,t,n){return e.parameters?.map(r=>{let a=m(t,r.type,!0,n)?.name??r.name;return s.createIdentifier(a)})??[]}function j(e,t){return s.createCallExpression(s.createIdentifier(e.name),void 0,t)}function $(e,t,n,r){return s.createVariableDeclaration(s.createIdentifier(e),void 0,void 0,h(t,n,r))}function R(e,t){let n=t.blocks.length,r=e.name.toLowerCase(),a={name:x(r,t.variables),type:f(e.returnType),index:n},i={functionInfo:e,parameters:e.parameters,returnVariable:a,isAsync:!!e.returnType?.includes(l),index:n,blockType:"functionCall"};return t.blocks.push(i),t.variables.push(a),i}function I(e,t){return V(e,t)}function d(e,t){switch(e.blockType){case"functionCall":return I(e,t);default:throw new Error(`Unknown block type: ${e.blockType}`)}}import{factory as g,createPrinter as G,createSourceFile as M,SyntaxKind as U,EmitHint as z,ScriptTarget as L}from"typescript";function O(e){let t={blocks:e,variables:[],isAsync:e.some(i=>i.isAsync)},n=e.map(i=>d(i,t)),r="generatedFunction",o=t.isAsync,a=g.createFunctionDeclaration(o?[g.createModifier(U.AsyncKeyword)]:void 0,void 0,r,void 0,[],void 0,g.createBlock(n));return G().printNode(z.Unspecified,a,M("temp.ts","",L.Latest))}import{Node as c,Project as q}from"ts-morph";function J(e){let t=new q;t.addSourceFilesAtPaths(`${e}/**/*.ts`);let n={functions:[],types:[]},r=t.getSourceFiles().filter(o=>!o.isInNodeModules());for(let o of r)o.forEachDescendant(a=>{if(c.isFunctionDeclaration(a)){let i=K(a);i&&n.functions.push(i)}else if(c.isVariableDeclaration(a)&&c.isArrowFunction(a.getInitializer())){let i=a.getInitializer();if(c.isArrowFunction(i)){let u={name:a.getName(),parameters:i.getParameters().map(T=>({name:T.getName(),type:T.getType().getText()})),returnType:i.getReturnType().getText()};n.functions.push(u)}}else if(c.isInterfaceDeclaration(a)||c.isClassDeclaration(a)){let i=X(a);i&&n.types.push(i)}});return n}function K(e){return c.isFunctionDeclaration(e)||c.isMethodDeclaration(e)?{name:e.getName()||"anonymous",parameters:e.getParameters().map(t=>({name:t.getName(),type:t.getType().getText()})),returnType:e.getReturnType().getText()}:null}function X(e){if(c.isInterfaceDeclaration(e)||c.isClassDeclaration(e)){let t=e.getName()||"Anonymous",n=e.getProperties().map(o=>({name:o.getName(),type:o.getType().getText()})),r={name:t,properties:n};return c.isClassDeclaration(e)&&(r.extends=e.getExtends()?.getText()?[e.getExtends().getText()]:void 0,r.implements=e.getImplements().map(o=>o.getText())),r}return null}var N={};A(N,{analyzeNextjsSourceFiles:()=>b,generateServerAction:()=>F,scanNextjsCodebase:()=>y});import{Project as _}from"ts-morph";function y(e){let t=new _;return t.addSourceFilesAtPaths(`${e}/**/*.ts`),b(t.getSourceFiles())}function b(e){let t=[];return e.forEach(n=>{H(n)&&t.push(...Q(n))}),{serverActions:t}}function H(e){return e.getFullText().trim().startsWith('"use server";')}function Q(e){let t=[];return e.getFunctions().forEach(n=>{if(n.isAsync()){let r={name:n.getName()||"anonymous",returnType:n.getReturnType().getText(),parameters:n.getParameters().map(o=>({name:o.getName(),type:o.getType().getText()})),filePath:e.getFilePath()};t.push(r)}}),t}function F(e){let t=(e.parameters??[]).map(r=>`${r.name}: ${r.type}`).join(", "),n=e.returnType.replace(/Promise<(.*)>/,"$1");return n=`Promise<${n}>`,`"use server";

export async function ${e.name}(${t}): ${n} {
  // TODO: Implement server action logic
  throw new Error("Not implemented");
}`}export{N as NextJS,d as blockToTypeScript,h as createFunctionCall,R as createFunctionCallBlock,V as createVariableWithFunctionCall,f as extractReturnType,P as extractVariables,m as findVariableByType,I as functionCallBlockToTypeScript,O as generateCode,F as generateServerAction,S as getFunctionInfoFromNode,p as getFunctionVariables,x as getUniqueVariableName,k as parseFunctionsFromText,J as scanCodebase,y as scanNextjsCodebase};
